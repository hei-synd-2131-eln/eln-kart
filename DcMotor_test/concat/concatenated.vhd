-- VHDL Entity DcMotor_test.dcMotorController_tb.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:40:50 09.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY dcMotorController_tb IS
-- Declarations

END dcMotorController_tb ;





--
-- VHDL Package Header Kart.Kart_Student
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 13:05:39 23.06.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE Kart_Student IS

--------------------------------------------------------------------------------
-- CHANGE THEM AS NEEDED, YOU CAN
--------------------------------------------------------------------------------
  -- When the circuit is in test mode
    --  (Stepper -> stepperMotorController -> testMode = '1'), the counter has
    --  to count quicker (to simplify on simulating the circuit).
    -- The following defines how many bits the counter should use.
    -- It simply creates a counter with that number of bits generating a pulse
    -- when it overflows, i.e. a pulse each 2**n / 10MHz => n = 8 : 25.6 [us]
  constant TESTMODE_PRESCALER_BIT_NB : positive := 8;

  -- Sensors
    -- The number of leds (or any output requiring a symmetrical PWM)
  constant NUMBER_OF_LEDS : positive := 4;

    -- The number of hall sensors
  constant NUMBER_OF_HALL_SENSORS : positive := 1;

    -- The number of external end switches (or any 0 - 3.3V input signal)
    -- A signal is sent to the smartphone on either rising or falling edge
  constant NUMBER_OF_EXT_END_SWITCHES : positive := 1;

    -- The number of proximity sensors used
    -- NORMALLY NONE
  constant NUMBER_OF_PROXIMITY_SENSORS : natural := 0;

    -- If the hallCounters block generates 2 pulses per turn (on rising AND 
    --  falling edges of the hallPulses) or only one
  constant HALLSENS_2PULSES_PER_TURN : std_ulogic := '1';

END Kart_Student;




--
-- VHDL Package Body Kart.Kart_Student
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 13:03:49 23.06.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
PACKAGE BODY Kart_Student IS
END Kart_Student;




--
-- VHDL Package Header Kart.Kart
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:30:31 11.05.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

Library Kart;
  Use Kart.Kart_Student.all;

PACKAGE Kart IS

-- Redefine student constants to make them available through this package
  constant TESTMODE_PRESCALER_BIT_NB : positive := TESTMODE_PRESCALER_BIT_NB;
  constant NUMBER_OF_LEDS : positive := NUMBER_OF_LEDS;
  constant NUMBER_OF_HALL_SENSORS : positive := NUMBER_OF_HALL_SENSORS;
  constant NUMBER_OF_EXT_END_SWITCHES : positive := NUMBER_OF_EXT_END_SWITCHES;
  constant NUMBER_OF_PROXIMITY_SENSORS : natural := NUMBER_OF_PROXIMITY_SENSORS;
  constant HALLSENS_2PULSES_PER_TURN : std_ulogic := HALLSENS_2PULSES_PER_TURN;

--------------------------------------------------------------------------------
-- YOUUUUUUUUU SHALL NOTTTTTTT TOUCH
--------------------------------------------------------------------------------

-- "Interesting" values to modify are highlighted as
  --|||||||||||||||
  --|||||||||||||||
    -- Interesting Value Description
  -- Value definition;
  --|||||||||||||||
  --|||||||||||||||


  -- Clocks	
  constant CLOCK_FREQUENCY  : real := 10.0E6;
  constant CLOCK_PERIOD 	: real := 1.0 / CLOCK_FREQUENCY;
  -- Sub clocks dividers (for counter based frequency dividers)
  constant CLOCK_1US_DIVIDER : positive := positive(CLOCK_FREQUENCY / 1.0E6);
  constant CLOCK_250US_DIVIDER : positive := 250*CLOCK_1US_DIVIDER;
  constant CLOCK_1MS_DIVIDER : positive := positive(CLOCK_FREQUENCY / 1.0E3);
  constant CLOCK_1S_DIVIDER : positive := positive(CLOCK_FREQUENCY / 1.0);

  --------------------------------------------

  -- UART

    -- Number of bits of data for each symbol
  constant UART_BIT_NB : positive  := 8;
    -- Number of bits to receive or send one symbol (i.e. data + start + stop)
  constant UART_TXRX_BIT_NB : positive  := UART_BIT_NB + 1 + 1;
  --|||||||||||||||
  --|||||||||||||||
    -- Baud rate
  constant UART_BAUD_RATE : positive  := 115200;
  --|||||||||||||||
  --|||||||||||||||
      -- Baud rate divider
  constant UART_BAUD_RATE_DIVIDER : positive :=
    positive(real(CLOCK_FREQUENCY) / real(UART_BAUD_RATE));

  -- CRC
    -- Size of bits sent before actual data
  constant HEADER_BIT_NB  : positive  := 8; -- 0xAA
    -- Address size
  constant ADDRESS_BIT_NB : positive  := 8;
    -- Value size
  constant VALUE_BIT_NB   : positive  := 16;
    -- CRC size
  constant CRC_BIT_NB     : positive  := 8;
    -- CRC-8/itu final xoring
  constant CRC_FINAL_XOR     : std_ulogic_vector(CRC_BIT_NB-1 downto 0)  := 
    std_ulogic_vector(to_unsigned(16#55#, CRC_BIT_NB));

  -- Frame (composed of 5 bytes as 0xAA | addr | data_high | data_low | crc)
    -- Header byte sent at the beginning of the frame
  constant FRAME_HEADER_BYTE : natural  := 16#AA#;
    -- Total frame size in bits
  constant FRAME_BIT_NB : positive := HEADER_BIT_NB + ADDRESS_BIT_NB 
      + VALUE_BIT_NB + CRC_BIT_NB;
    -- Total frame size in bytes
  constant FRAME_BYTES_NB : real := real(FRAME_BIT_NB) / real(UART_BIT_NB);
    -- Symbols per frame
  constant NB_SYMBOL_P_FRAME : natural := natural(FRAME_BIT_NB / UART_BIT_NB);

  -- Tx buffer
  --|||||||||||||||
  --|||||||||||||||
    -- Depth of the Tx buffer
    -- MUST BE POWER OF 2, else will SIGSEV !!!
  constant TX_BUFFER_WANTED_DEPTH : positive := 64;
  --|||||||||||||||
  --|||||||||||||||
    -- Will be calculated
  function check_pow_2(size : positive) return positive;
  constant TX_BUFFER_SIZE : positive;


  --------------------------------------------

  -- Data definition

    -- Size of a symbol (i.e. a byte)
  subtype symbolSizeType is std_ulogic_vector(UART_BIT_NB-1 downto 0);
    -- Size of the frame
  type frameSizeType is array(NB_SYMBOL_P_FRAME-1 downto 0)
    of symbolSizeType;
    -- Array of register
  subtype dataRegisterType is std_ulogic_vector(VALUE_BIT_NB-1 downto 0);
  type dataRegisterArrayType is array(ADDRESS_BIT_NB-1 downto 0) 
      of dataRegisterType;
      -- Unconstrained array, defined on instanciation
  type registersHolderType is array(integer range <>)
      of dataRegisterType;


  -- How registers and address are decoded
    -- Address byte definition :
      -- b 7 .. 6 : module address
      -- b 5      : write to (FRAME_WBIT_VALUE) - read from (!FRAME_WBIT_VALUE)
      -- b 4 .. 0 : which register

    -- How many bits (MSB side) will define the module
  constant REG_ADDR_MSB_NB_BITS : positive := 2;
    -- Where the write/read bit is located
  constant REG_ADDR_GET_BIT_POSITION : positive
    := UART_BIT_NB - REG_ADDR_MSB_NB_BITS - 1;
    -- How many bits to define actual register per module (2**n)
  constant REG_ADDR_MAXNBREG_BITS : positive
    := UART_BIT_NB - REG_ADDR_MSB_NB_BITS - 1;
    -- Where actual register is located in address byte
  subtype REG_ADDR_REG_RANGE is natural range REG_ADDR_MAXNBREG_BITS-1 downto 0;
    -- How many registers are possible per module
  subtype REG_COUNT_RANGE is integer range 0 to (2**REG_ADDR_MAXNBREG_BITS)-1;
  --|||||||||||||||
  --|||||||||||||||
    -- Value of the W bit when wanting to write into a register
  constant FRAME_WBIT_VALUE : std_ulogic := '1';
  --|||||||||||||||
  --|||||||||||||||


  -- I2C
    -- Data bits (8) + special coding for transceiver (2)
  constant I2C_BIT_NB : positive := 10;


  --------------------------------------------

  -- DC motor

  constant REG_DCMOT_ADDR : natural := 0;
    -- How many writable registers
  constant DC_REG_COUNT : positive := 2;
    -- Total count of register
  constant DC_TOT_REG_COUNT : positive := 2;

  -- Regs defs
  constant DC_PRESCALER_REG_POS : natural := 0;
  constant DC_SPEED_REG_POS : natural := 1;

  -- Others
  constant DC_prescalerBitNb : positive := 16;
  constant DC_speedBitNb : positive := 16;
  constant DC_pwmStepsBitNb : positive := 5; -- +- 15


  --------------------------------------------

  -- Stepper motor

  constant REG_STEP_ADDR : natural := 1;
    -- How many writable registers
  constant STP_REG_COUNT : positive := 2;
    -- Total count of register
  constant STP_TOT_REG_COUNT : positive := 4;

  -- Regs defs
  constant STP_CLOCKDIVIDER_REG_POS : natural := 0;
  constant STP_TARGETANGLE_REG_POS : natural := 1;
  constant STP_ANGLE_EXT_REG_POS : natural := 2;
  constant STP_HW_EXT_REG_POS : natural := 3;

  -- Event based definitions
  --|||||||||||||||
  --|||||||||||||||
    -- Motor def
  constant STP_STEPS_P_TURN : positive := 48;
  constant STP_REDUCTOR : real := 100.0;
    -- Motor has 4800 steps / 360Â° => 40 steps is 3Â° resol.
  constant STP_ANGLE_DELTA_DEG : positive := 10;
  --|||||||||||||||
  --|||||||||||||||
  constant STP_ANGLE_DELTA : integer :=
    integer(real(STP_ANGLE_DELTA_DEG mod 360) * (real(STP_STEPS_P_TURN) *
      STP_REDUCTOR) / 360.0);

  -- Others
  constant STP_testPrescalerBitNb : positive := TESTMODE_PRESCALER_BIT_NB;
  constant STP_dividerBitNb : positive := 16;
  constant STP_angleBitNb : positive := 12;
    -- The stepper base frequency which the prescaler is then applied to
  constant STP_MAX_FREQ : real := 100.0E3;
    -- Output coil PWM steps nb
  constant STP_PWM_NB_STEPS : positive := 10;
    -- Output coil DC
  constant STP_PWM_DC : real := 0.2;
    -- Output coil PWM cnt target
  constant STP_PWM_CNT_TARGET : positive :=
    positive(CLOCK_FREQUENCY / (STP_MAX_FREQ * real(STP_PWM_NB_STEPS)));
    -- Output coil DC cnt target
  constant STP_PWM_CNT_ON : positive := positive(
    real(STP_PWM_CNT_TARGET) * STP_PWM_DC);


  --------------------------------------------

  -- Sensors

    -- Required for registers definition
  constant SENS_ledNb : positive := NUMBER_OF_LEDS;
  constant SENS_hallSensorNb : positive := NUMBER_OF_HALL_SENSORS;
  constant SENS_proximitySensorNb : natural := NUMBER_OF_PROXIMITY_SENSORS;
  constant SENS_endSwitchNb : positive := NUMBER_OF_EXT_END_SWITCHES;
  
  constant REG_SENS_ADDR : natural := 2;
    -- How many writable registers
  constant SENS_REG_COUNT : positive := 1 + SENS_ledNb;
    -- Total count of register
  constant SENS_TOT_REG_COUNT : positive :=
    SENS_REG_COUNT + SENS_hallSensorNb + 2 * SENS_proximitySensorNb + 4;
      
  -- Regs defs
  constant SENS_REFRESH_PROXI_REG_POS : natural := 0;
  constant SENS_LEDS_REG_POS : natural := 1; -- up to SENS_ledNb
  constant SENS_BATTERY_EXT_REG_POS : natural := SENS_ledNb + 1;
  constant SENS_CURRENT_EXT_REG_POS : natural := SENS_ledNb + 2;
  constant SENS_RANGEFNDR_EXT_REG_POS : natural := SENS_ledNb + 3;
  constant SENS_ENDSWITCHES_EXT_REG_POS : natural := SENS_ledNb + 4;
  constant SENS_HALLCNT_EXT_REG_POS : natural := SENS_ledNb + 5;
    -- up to SENS_ledNb + SENS_hallSensorNb + 4
  constant SENS_PROXIMITY_EXT_REG_POS : natural :=
    SENS_ledNb + SENS_hallSensorNb + 5;
    -- up to SENS_ledNb + SENS_hallSensorNb + SENS_proximitySensorNb + 4
  constant SENS_AMBIENTLIGHT_EXT_REG_POS : natural :=
    SENS_ledNb + SENS_hallSensorNb + SENS_proximitySensorNb + 5;
    -- up to SENS_ledNb + SENS_hallSensorNb + 2 * SENS_proximitySensorNb + 4

  -- Event based definitions
  --|||||||||||||||
  --|||||||||||||||
      -- Voltage value is n * 250uV * 7.8 [V] => delta of 100mV = 51.28
  constant SENS_BATT_DELTA_MV : positive := 100;
    -- Delta for current
      -- Current value is n * 250uA / (100 * 5m) [A] => delta of 100mA = 200
  constant SENS_CURR_DELTA_MA : positive := 50;
      -- Distance value is n * 25.4 / (147u * (fclk/rangedvd)) [mm] => delta of 10mm = 57.87
  constant SENS_RANGEFNDR_CLK_DIVIDER : positive :=
    positive(CLOCK_FREQUENCY / 1000000.0);
        -- if zero, no auto send
  constant SENS_RANGEFNDR_MM : natural := 100;
        -- min value for send
  constant SENS_RANGEFNDR_MIN_MM : natural := 152;
        -- max value for send
  constant SENS_RANGEFNDR_MAX_MM : positive := 1500;
      -- HallCount definition
        -- How many 1/2 turns before the hall speed is sent
  constant SENS_HALLCOUNT_HALF_TURN_DELTA : positive := 20;
        -- Base time for Hall Count
  constant SENS_HALL_CLOCK_DIVIDER : positive := 4*CLOCK_1MS_DIVIDER;
        -- Number of clocks the signal must be stable for registering
  constant SENS_HALL_NB_CLOCKS_FILTER : positive := 7;
    -- Delta for proximities, unknown unit
  constant SENS_PROXI_DELTA : positive := 255;
    -- Delta for ambient, unknown unit
  constant SENS_AMBIENT_DELTA : positive := 255;
  --|||||||||||||||
  --|||||||||||||||
        -- Delta in "register unit"
  constant SENS_BATT_DELTA : positive :=
    positive(real(SENS_BATT_DELTA_MV) / (1000.0 * 7.8 * 250.0E-6));
  constant SENS_CURR_DELTA : positive :=
    positive((real(SENS_CURR_DELTA_MA) * 100.0 * 5.0E-3) / (1000.0 * 250.0E-6));
  constant SENS_RANGEFNDR_DELTA : natural :=
    natural(
      (real(SENS_RANGEFNDR_MM) * 0.000147 *
      (CLOCK_FREQUENCY / real(SENS_RANGEFNDR_CLK_DIVIDER))) / 25.4
    );
  constant SENS_RANGEFNDR_MIN_DELTA : natural  :=
    natural(
      (real(SENS_RANGEFNDR_MIN_MM) * 0.000147 *
      (CLOCK_FREQUENCY / real(SENS_RANGEFNDR_CLK_DIVIDER))) / 25.4
    );
  constant SENS_RANGEFNDR_MAX_DELTA : positive :=
    positive(
      (real(SENS_RANGEFNDR_MAX_MM) * 0.000147 *
      (CLOCK_FREQUENCY / real(SENS_RANGEFNDR_CLK_DIVIDER))) / 25.4
    );
  function hall_check(nb_half_turn : positive) return positive;
  constant SENS_HALLCOUNT_TURN_DELTA : positive;

  -- Others
    -- Battery
      -- I2C baudrate
  --|||||||||||||||
  --|||||||||||||||
  constant SENS_batteryBaudRate: real := 100.0E3;
  --|||||||||||||||
  --|||||||||||||||
  constant SENS_batteryBaudRateDivide: positive :=
    integer(CLOCK_FREQUENCY/SENS_batteryBaudRate / 4.0);
      -- How many tries before cancelling transaction with battery reader
  constant SENS_BATT_READ_RETRIES : positive := 5;
      -- Sens read timeout
        -- With 60 SPS -> time of arnd. 17 ms
  constant SENS_BATT_READ_TMOUT_MS : positive := 20;
    -- Ranger
  constant SENS_rangeBitNb : positive := 16;
      -- Time in MS the pulse should not exceed and/or min time btw. two reads
      --  (i.e. problem with sensor or unwired)
  constant SENS_rangeTimeoutBeforeStartMS : positive := 300;
    -- Hall sensors
  constant SENS_hallCountBitNb : positive := 16;
      -- Number of bits that can be used for counter. Final register is such as:
      --  5bits   : number of 1/2 turns done
      --  11 bits : time elapsed for the number of turns counted in 4 ms 
  constant SENS_HALL_CNT_BITNB : positive := 11;
  constant SENS_HALL_TURNS_BITNB : positive :=
    SENS_hallCountBitNb - SENS_HALL_CNT_BITNB;
      -- If should count 2 pulses per turn or only 1
  constant SENS_HALL_COUNTS_2PULSES_P_TURN : std_ulogic
    := HALLSENS_2PULSES_PER_TURN;
    -- Proximity
  constant SENS_proximityBaseAddress: natural := 16;
  constant SENS_ambientLightBitNb: positive := 16;
  constant SENS_proximityBitNb: positive := 16;
      -- I2C baudrate
  --|||||||||||||||
  --|||||||||||||||
  constant SENS_proximityBaudRate: real := 100.0E3;
  --|||||||||||||||
  --|||||||||||||||
  constant SENS_proximityBaudRateDivide: positive :=
    integer(CLOCK_FREQUENCY/SENS_proximityBaudRate / 4.0);


  --------------------------------------------

  -- Control registers
  constant REG_CR_ADDR : natural := 3;
    -- How many writable registers
  constant CR_REG_COUNT : positive := 1;
    -- Total count of register
  constant CR_TOT_REG_COUNT : positive := 1;

  constant CR_HARDWARE_CONTROL_REG_POS : natural := 0;

  -- Hardware control bits
  constant HW_CTRL_FORWARDS_BIT : natural := 0;
  constant HW_CTRL_CLOCKWISE_BIT : natural := 1;
  constant HW_CTRL_ANGLES_BIT : natural := 2;
  constant HW_CTRL_ENDSW_BIT : natural := 3;
  constant HW_CTRL_RESTART_BIT : natural := 4;
  constant HW_CTRL_BLECONN_BIT : natural := 5;

END Kart;



package body Kart is

  -- Tx buffer
  function check_pow_2(size : positive) return positive is
  begin
    assert(
      (
        to_unsigned(size, 32) and to_unsigned(size-1, 32)
      ) = (32=>'0') )
      report "TX_BUFFER_WANTED_DEPTH must be a power of two" severity failure;
    return size;
  end function check_pow_2;

  constant TX_BUFFER_SIZE : positive := check_pow_2(TX_BUFFER_WANTED_DEPTH);

  -- Hall
  function hall_check(nb_half_turn : positive) return positive is
  begin
    assert(nb_half_turn < 2**SENS_HALL_TURNS_BITNB and nb_half_turn mod 2 = 0)
      report
      "SENS_HALLCOUNT_HALF_TURN_DELTA must be even and smaller than " &
        positive'image(2**SENS_HALL_TURNS_BITNB)
      severity failure;
    return nb_half_turn;
  end function hall_check;

  constant SENS_HALLCOUNT_TURN_DELTA : positive :=
    hall_check(SENS_HALLCOUNT_HALF_TURN_DELTA);

end package body Kart;




-- VHDL Entity DcMotor.dcMotorController.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 12:53:19 23.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;


LIBRARY Kart;
USE Kart.Kart.ALL;

ENTITY dcMotorController IS
    PORT( 
        addressIn            : IN     symbolSizeType;
        clock                : IN     std_ulogic;
        dataIn               : IN     dataRegisterType;
        dcMotorSendAuth      : IN     std_ulogic;
        hwOrientation        : IN     dataRegisterType;
        regWr                : IN     std_ulogic;
        reset                : IN     std_ulogic;
        dcMotorAddressToSend : OUT    symbolSizeType;
        dcMotorDataToSend    : OUT    dataRegisterType;
        dcMotorSendRequest   : OUT    std_ulogic;
        forwards             : OUT    std_ulogic;
        pwm                  : OUT    std_ulogic
    );

-- Declarations

END dcMotorController ;





-- VHDL Entity DcMotor.dcMotorPrescaler.symbol
--
-- Created:
--          by - francois.corthay.UNKNOWN (WEA20302)
--          at - 10:08:36 27.08.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY dcMotorPrescaler IS
    GENERIC( 
        prescalerBitNb : positive := 16
    );
    PORT( 
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        pwmEn     : OUT    std_ulogic;
        prescaler : IN     unsigned (prescalerBitNb-1 DOWNTO 0)
    );

-- Declarations

END dcMotorPrescaler ;





ARCHITECTURE RTL OF dcMotorPrescaler IS

  signal prescalerCounter: unsigned(prescaler'range);
  signal prescalerDone: std_ulogic;

BEGIN

  divideClock: process(reset, clock)
  begin
    if reset = '1' then
      prescalerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if prescalerDone = '1' then
        prescalerCounter <= (others => '0');
      else
        prescalerCounter <= prescalerCounter + 1;
      end if;
    end if;
  end process divideClock;

  prescalerDone <= '1' when prescalerCounter+1 >= prescaler
    and prescaler /= (prescaler'range=>'0') else '0';
  pwmEn <= prescalerDone;

END ARCHITECTURE RTL;




-- VHDL Entity DcMotor.dcMotorPwm.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:22:25 22.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY dcMotorPwm IS
    GENERIC( 
        pwmStepsBitNb : positive := 5;
        speedBitNb    : positive := 5
    );
    PORT( 
        clock           : IN     std_ulogic;
        reset           : IN     std_ulogic;
        en              : IN     std_ulogic;
        speed           : IN     signed (speedBitNb-1 DOWNTO 0);
        pwmOut          : OUT    std_ulogic;
        forwards        : OUT    std_ulogic;
        normalDirection : IN     std_ulogic;
        restart         : IN     std_ulogic;
        btConnected     : IN     std_ulogic
    );

-- Declarations

END dcMotorPwm ;





ARCHITECTURE masterVersion OF dcMotorPwm IS

  signal sign: std_ulogic;
  signal speedAmplitude: unsigned(speed'high-1 downto 0);
  signal last_speed : signed(speed'range);
  signal sawtooth: unsigned(pwmStepsBitNb-2 downto 0);
  signal inhibit, waitNewEn : std_ulogic;

BEGIN

  ------------------------------------------------------------------------------
                                                                    -- direction
  sign <= speed(speed'high);
  forwards <= not sign when normalDirection = '1'
    else sign;

  ------------------------------------------------------------------------------
                                                                          -- PWM
  inhibit <= '1' when btConnected = '0' or restart = '1' else '0';
  speedAmplitude <= unsigned(speed(speedAmplitude'range)) when sign = '0'
    else unsigned(-speed(speedAmplitude'range));

  storeValues: process(reset, clock)
  begin
    if reset = '1' then
      sawtooth <= (others => '0');
      last_speed <= (others=>'0');
      waitNewEn <= '1';
    elsif rising_edge(clock) then
      if speed /= last_speed then
        waitNewEn <= '1';
      end if;
      if en = '1' then
        waitNewEn <= '0';
        sawtooth <= sawtooth + 1;
      end if;
      last_speed <= speed;
    end if;
  end process storeValues;

  pwmOut <= '0' when (speedAmplitude = 0) or (inhibit = '1') or waitNewEn = '1'
    else '1' when sawtooth <= speedAmplitude(sawtooth'range)
    else '0';

END ARCHITECTURE masterVersion;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity DcMotor.dcMotorRegisters.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 12:53:10 23.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Kart;
USE Kart.Kart.ALL;

LIBRARY Common;
USE Common.CommonLib.ALL;

LIBRARY gates;
USE gates.gates.all;

ENTITY dcMotorRegisters IS
    PORT( 
        addressIn            : IN     symbolSizeType;
        clock                : IN     std_ulogic;
        dataIn               : IN     dataRegisterType;
        dcMotorSendAuth      : IN     std_ulogic;
        regWr                : IN     std_ulogic;
        reset                : IN     std_ulogic;
        dcMotorAddressToSend : OUT    symbolSizeType;
        dcMotorDataToSend    : OUT    dataRegisterType;
        dcMotorSendRequest   : OUT    std_ulogic;
        prescaler            : OUT    unsigned (DC_prescalerBitNb-1 DOWNTO 0);
        speed                : OUT    signed (DC_speedBitNb-1 DOWNTO 0)
    );

-- Declarations

END dcMotorRegisters ;





-- VHDL Entity Kart.reg_addr_decoder.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:39:40 13.05.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Common;
  USE Common.CommonLib.ALL;

LIBRARY Kart;
  USE Kart.Kart.ALL;

ENTITY reg_addr_decoder IS
    GENERIC( 
        moduleAddr : natural := 0
    );
    PORT( 
        address      : IN     symbolSizeType;
        wr           : IN     std_ulogic;
        loadRegister : OUT    std_ulogic;
        readRegister : OUT    std_ulogic
    );

-- Declarations

END reg_addr_decoder ;





--
-- VHDL Architecture Kart.reg_addr_decoder.rtl
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 10:49:17 12.05.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--

Library Kart;
  USE Kart.Kart.all;

ARCHITECTURE rtl OF reg_addr_decoder IS

signal p_module_selected : std_ulogic;

BEGIN

  p_module_selected <= '1' when address(address'high downto address'high - 
      REG_ADDR_MSB_NB_BITS + 1) = std_ulogic_vector(to_unsigned(moduleAddr, REG_ADDR_MSB_NB_BITS)) and wr = '1' else '0';

  loadRegister <= '1' when p_module_selected = '1' and address(REG_ADDR_GET_BIT_POSITION) = FRAME_WBIT_VALUE else '0';
  readRegister <= '1' when p_module_selected = '1' and address(REG_ADDR_GET_BIT_POSITION) = not FRAME_WBIT_VALUE else '0';

END ARCHITECTURE rtl;




-- VHDL Entity Kart.registerManager.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:57:34 13.05.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Common;
  USE Common.CommonLib.ALL;

LIBRARY Kart;
  USE Kart.Kart.ALL;

ENTITY registerManager IS
    GENERIC( 
        registersNb : positive := 7
    );
    PORT( 
        addressIn : IN     symbolSizeType;
        clock     : IN     std_ulogic;
        dataIn    : IN     dataRegisterType;
        loadNew   : IN     std_ulogic;
        reset     : IN     std_ulogic;
        bankData  : OUT    registersHolderType (registersNb-1 DOWNTO 0)
    );

-- Declarations

END registerManager ;





--
-- VHDL Architecture Kart.registerManager.rtl
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 13:15:36 12.05.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--

Library Kart;
  USE Kart.Kart.ALL;

ARCHITECTURE rtl OF registerManager IS

  -- Registers
    -- Actual registers bank
  signal p_registers : registersHolderType(registersNb-1 downto 0);
  signal p_int_reg_addr : REG_COUNT_RANGE;
BEGIN

  p_int_reg_addr <= to_integer(unsigned(addressIn(REG_ADDR_REG_RANGE)));

  -- Registers read
  bankData <= p_registers;

  --------------------------------------------------------------

  -- Registers input
  register_input: process(reset,clock)
  begin
    if reset = '1' then
      p_registers <= (others=>(others=>'0'));
    elsif rising_edge(clock) then
      -- On load + ensure register exists
      if loadNew = '1' and p_int_reg_addr < registersNb then
        p_registers(p_int_reg_addr) <= dataIn;
      end if;
    end if;
  end process register_input;

END ARCHITECTURE rtl;




-- VHDL Entity DcMotor.dcMotorRegisterSender.symbol
--
-- Created:
--          by - axela.UNKNOWN (I12)
--          at - 17:07:23 24.05.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Kart;
USE Kart.Kart.ALL;

LIBRARY Common;
USE Common.CommonLib.ALL;

LIBRARY gates;
USE gates.gates.all;

ENTITY dcMotorRegisterSender IS
    GENERIC( 
        registersNb   : positive := 8;
        moduleAddr    : natural  := 0;
        inRegistersNb : positive := 4
    );
    PORT( 
        addressIn            : IN     symbolSizeType;
        bankData             : IN     registersHolderType (inRegistersNb-1 DOWNTO 0);
        clock                : IN     std_ulogic;
        dcMotorSendAuth      : IN     std_ulogic;
        reset                : IN     std_ulogic;
        sendRxRegister       : IN     std_ulogic;
        dcMotorAddressToSend : OUT    symbolSizeType;
        dcMotorDataToSend    : OUT    dataRegisterType;
        dcMotorSendRequest   : OUT    std_ulogic
    );

-- Declarations

END dcMotorRegisterSender ;





--
-- VHDL Architecture DcMotor.dcMotorRegisterSender.rtl
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:32:53 13.05.2022
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--

Library Kart;
  USE Kart.Kart.ALL;

ARCHITECTURE rtl OF dcMotorRegisterSender IS

  -- Send state machine states
  type statesType is (
      idle, request
    );
  signal p_state : statesType;

      -- Address that will be output
  signal p_addr_out : symbolSizeType;
  signal p_data_out : dataRegisterType;
  signal p_request : std_ulogic;
  signal p_int_reg_addr : REG_COUNT_RANGE;

BEGIN

  p_int_reg_addr <= to_integer(unsigned(addressIn(REG_ADDR_REG_RANGE)));

  register_send: process(reset, clock)
  begin
    if reset = '1' then
      p_request <= '0';
      p_addr_out <= (others=>'0');
      p_data_out <= (others=>'0');
      p_state <= idle;
    elsif rising_edge(clock) then
      case p_state is
        -- Check for send request
        when idle =>
          -- Request from Rx
          if sendRxRegister = '1' then
            -- Ensure the requested register exists
            if p_int_reg_addr < registersNb then
              p_addr_out <= addressIn;
              p_request <= '1';
              p_state <= request;
              -- Check if is a standard or "external" register
              p_data_out <= bankData(p_int_reg_addr);
            end if;
          end if;

        when request =>
          if dcMotorSendAuth = '1' then
            p_request <= '0';
            p_state <= idle;
          end if;

        when others => p_state <= idle;

      end case;
    end if;
  end process register_send;

  dcMotorSendRequest <= p_request;
  dcMotorAddressToSend <= p_addr_out;
  dcMotorDataToSend <= p_data_out;

END ARCHITECTURE rtl;




--
-- VHDL Architecture DcMotor.dcMotorRegisters.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 12:53:10 23.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Kart;
USE Kart.Kart.ALL;

LIBRARY Common;
USE Common.CommonLib.ALL;

LIBRARY gates;
USE gates.gates.all;

LIBRARY DcMotor;

ARCHITECTURE struct OF dcMotorRegisters IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL bankData     : registersHolderType(DC_REG_COUNT-1 DOWNTO 0);
    SIGNAL loadRegister : std_ulogic;
    SIGNAL readRegister : std_ulogic;


    -- Component Declarations
    COMPONENT dcMotorRegisterSender
    GENERIC (
        registersNb   : positive := 8;
        moduleAddr    : natural  := 0;
        inRegistersNb : positive := 4
    );
    PORT (
        addressIn            : IN     symbolSizeType ;
        bankData             : IN     registersHolderType (inRegistersNb-1 DOWNTO 0);
        clock                : IN     std_ulogic ;
        dcMotorSendAuth      : IN     std_ulogic ;
        reset                : IN     std_ulogic ;
        sendRxRegister       : IN     std_ulogic ;
        dcMotorAddressToSend : OUT    symbolSizeType ;
        dcMotorDataToSend    : OUT    dataRegisterType ;
        dcMotorSendRequest   : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT reg_addr_decoder
    GENERIC (
        moduleAddr : natural := 0
    );
    PORT (
        address      : IN     symbolSizeType ;
        wr           : IN     std_ulogic ;
        loadRegister : OUT    std_ulogic ;
        readRegister : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT registerManager
    GENERIC (
        registersNb : positive := 7
    );
    PORT (
        addressIn : IN     symbolSizeType ;
        clock     : IN     std_ulogic ;
        dataIn    : IN     dataRegisterType ;
        loadNew   : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        bankData  : OUT    registersHolderType (registersNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : dcMotorRegisterSender USE ENTITY DcMotor.dcMotorRegisterSender;
    FOR ALL : reg_addr_decoder USE ENTITY Kart.reg_addr_decoder;
    FOR ALL : registerManager USE ENTITY Kart.registerManager;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    prescaler <= unsigned(bankData(DC_PRESCALER_REG_POS));

    -- HDL Embedded Text Block 2 eb2
    speed <= signed(bankData(DC_SPEED_REG_POS));


    -- Instance port mappings.
    U_sender : dcMotorRegisterSender
        GENERIC MAP (
            registersNb   => DC_TOT_REG_COUNT,
            moduleAddr    => REG_DCMOT_ADDR,
            inRegistersNb => DC_REG_COUNT
        )
        PORT MAP (
            addressIn            => addressIn,
            bankData             => bankData,
            clock                => clock,
            dcMotorSendAuth      => dcMotorSendAuth,
            reset                => reset,
            sendRxRegister       => readRegister,
            dcMotorAddressToSend => dcMotorAddressToSend,
            dcMotorDataToSend    => dcMotorDataToSend,
            dcMotorSendRequest   => dcMotorSendRequest
        );
    U_decoder : reg_addr_decoder
        GENERIC MAP (
            moduleAddr => REG_DCMOT_ADDR
        )
        PORT MAP (
            address      => addressIn,
            wr           => regWr,
            loadRegister => loadRegister,
            readRegister => readRegister
        );
    U_manager : registerManager
        GENERIC MAP (
            registersNb => DC_REG_COUNT
        )
        PORT MAP (
            addressIn => addressIn,
            clock     => clock,
            dataIn    => dataIn,
            loadNew   => loadRegister,
            reset     => reset,
            bankData  => bankData
        );

END struct;




--
-- VHDL Architecture DcMotor.dcMotorController.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 12:53:19 23.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Kart;
USE Kart.Kart.ALL;

LIBRARY Common;
USE Common.CommonLib.ALL;

LIBRARY gates;
USE gates.gates.all;

LIBRARY DcMotor;

ARCHITECTURE struct OF dcMotorController IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL prescaler : unsigned(DC_prescalerBitNb-1 DOWNTO 0);
    SIGNAL pwmEn     : std_ulogic;
    SIGNAL speed     : signed(DC_speedBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT dcMotorPrescaler
    GENERIC (
        prescalerBitNb : positive := 16
    );
    PORT (
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        pwmEn     : OUT    std_ulogic ;
        prescaler : IN     unsigned (prescalerBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT dcMotorPwm
    GENERIC (
        pwmStepsBitNb : positive := 5;
        speedBitNb    : positive := 5
    );
    PORT (
        clock           : IN     std_ulogic ;
        reset           : IN     std_ulogic ;
        en              : IN     std_ulogic ;
        speed           : IN     signed (speedBitNb-1 DOWNTO 0);
        pwmOut          : OUT    std_ulogic ;
        forwards        : OUT    std_ulogic ;
        normalDirection : IN     std_ulogic ;
        restart         : IN     std_ulogic ;
        btConnected     : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT dcMotorRegisters
    PORT (
        addressIn            : IN     symbolSizeType ;
        clock                : IN     std_ulogic ;
        dataIn               : IN     dataRegisterType ;
        dcMotorSendAuth      : IN     std_ulogic ;
        regWr                : IN     std_ulogic ;
        reset                : IN     std_ulogic ;
        dcMotorAddressToSend : OUT    symbolSizeType ;
        dcMotorDataToSend    : OUT    dataRegisterType ;
        dcMotorSendRequest   : OUT    std_ulogic ;
        prescaler            : OUT    unsigned (DC_prescalerBitNb-1 DOWNTO 0);
        speed                : OUT    signed (DC_speedBitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : dcMotorPrescaler USE ENTITY DcMotor.dcMotorPrescaler;
    FOR ALL : dcMotorPwm USE ENTITY DcMotor.dcMotorPwm;
    FOR ALL : dcMotorRegisters USE ENTITY DcMotor.dcMotorRegisters;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_div : dcMotorPrescaler
        GENERIC MAP (
            prescalerBitNb => DC_prescalerBitNb
        )
        PORT MAP (
            clock     => clock,
            reset     => reset,
            pwmEn     => pwmEn,
            prescaler => prescaler
        );
    I_pwm : dcMotorPwm
        GENERIC MAP (
            pwmStepsBitNb => DC_pwmStepsBitNb,
            speedBitNb    => DC_speedBitNb
        )
        PORT MAP (
            clock           => clock,
            reset           => reset,
            en              => pwmEn,
            speed           => speed,
            pwmOut          => pwm,
            forwards        => forwards,
            normalDirection => hwOrientation(HW_CTRL_FORWARDS_BIT),
            restart         => hwOrientation(HW_CTRL_RESTART_BIT),
            btConnected     => hwOrientation(HW_CTRL_BLECONN_BIT)
        );
    I_regs : dcMotorRegisters
        PORT MAP (
            addressIn            => addressIn,
            clock                => clock,
            dataIn               => dataIn,
            dcMotorSendAuth      => dcMotorSendAuth,
            regWr                => regWr,
            reset                => reset,
            dcMotorAddressToSend => dcMotorAddressToSend,
            dcMotorDataToSend    => dcMotorDataToSend,
            dcMotorSendRequest   => dcMotorSendRequest,
            prescaler            => prescaler,
            speed                => speed
        );

END struct;




-- VHDL Entity DcMotor_test.dcMotorController_tester.interface
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:43:31 09.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY Kart;
USE Kart.Kart.ALL;

ENTITY dcMotorController_tester IS
    PORT( 
        dcMotorAddressToSend : IN     symbolSizeType;
        dcMotorDataToSend    : IN     dataRegisterType;
        dcMotorSendRequest   : IN     std_ulogic;
        forwards             : IN     std_ulogic;
        pwm                  : IN     std_ulogic;
        addressIn            : OUT    symbolSizeType;
        clock                : OUT    std_ulogic;
        dataIn               : OUT    dataRegisterType;
        dcMotorSendAuth      : OUT    std_ulogic;
        hwOrientation        : OUT    dataRegisterType;
        regWr                : OUT    std_ulogic;
        reset                : OUT    std_ulogic
    );

-- Declarations

END dcMotorController_tester ;





LIBRARY std;
  USE std.textio.all;
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

PACKAGE testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string);


  --============================================================================
  -- string manipulation
  --

                                                      -- conversion to lowercase
  function lc(value : string) return string;
  procedure lc(value : inout line);
                                                      -- conversion to uppercase
  function uc(value : string) return string;
  procedure uc(value : inout line);
                                            -- expand a string to a given length
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string;
                     -- remove separator characters at beginning and end of line
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  );
  procedure rm_side_separators(
    value : inout line
  );
                           -- remove multiple occurences of separator characters
  procedure trim_line(
    value : inout line;
    separators : in string
  );

  procedure trim_line(
    value : inout line
   );
                                -- remove all occurences of separator characters
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  );

  procedure rm_all_separators(
    value : inout line
  );
                                                   -- find and remove first word
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  );

  procedure read_first(
    value : inout line;
    first : out line
   );
                                                    -- find and remove last word
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  );

  procedure read_last(
    value : inout line;
    last : out line
   );


  --============================================================================
  -- formatted string output
  --
  -- format codes:
  --  code  integer real std_logic std_(u)logic_vector (un)signed time
  --    b       v            v               v              v           binary
  --    c                                                               character
  --    d       v     v      v               v              v           decimal
  --    e                                                               real numbers, with power of 10 exponent
  --    f       v     v                                                 fixed point real numbers
  --    s                                                               string
  --    ts                                                          v   time in seconds
  --    tm                                                          v   time in milliseconds
  --    tu                                                          v   time in microseconds
  --    tn                                                          v   time in nanoseconds
  --    tp                                                          v   time in picoseconds
  --    x       v            v               v              v           hexadecimal
  --    X       v            v               v              v           hexadecimal with upper-case letters

  function sprintf(format : string; value : integer          ) return string;
  function sprintf(format : string; value : real             ) return string;
  function sprintf(format : string; value : std_logic        ) return string;
  function sprintf(format : string; value : std_ulogic_vector) return string;
  function sprintf(format : string; value : std_logic_vector ) return string;
  function sprintf(format : string; value : unsigned         ) return string;
  function sprintf(format : string; value : signed           ) return string;
  function sprintf(format : string; value : time             ) return string;

  --============================================================================
  -- formatted string input
  --
  subtype nibbleUlogicType is std_ulogic_vector(3 downto 0);
  subtype nibbleUnsignedType is unsigned(3 downto 0);

  function sscanf(value : character) return natural;
  function sscanf(value : character) return nibbleUlogicType;
  function sscanf(value : character) return nibbleUnsignedType;
  function sscanf(value : string   ) return natural;
  function sscanf(value : string   ) return unsigned;
  function sscanf(value : string   ) return std_ulogic_vector;
  function sscanf(value : string   ) return time;

  procedure sscanf(value : inout line; time_val : out time);

END testUtils;




PACKAGE BODY testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string) is
    variable my_line : line;
  begin
    write(my_line, value);
    writeLine(output, my_line);
    deallocate(my_line);
  end print;


  --============================================================================
  -- string manipulation
  --

  ------------------------------------------------------------------------------
  -- change to lowercase
  ------------------------------------------------------------------------------
  procedure lc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'A') and (value(index) <= 'Z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('A')
                                    + character'pos('a')
                                      );
      end if;
    end loop;
  end lc;

  function lc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    lc(out_line);
    return(out_line.all);
  end lc;

  ------------------------------------------------------------------------------
  -- change to uppercase
  ------------------------------------------------------------------------------
  procedure uc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'a') and (value(index) <= 'z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('a')
                                    + character'pos('A')
                                      );
      end if;
    end loop;
  end uc;

  function uc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    uc(out_line);
    return(out_line.all);
  end uc;

  ------------------------------------------------------------------------------
  -- formatted string output: padding and justifying
  ------------------------------------------------------------------------------
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string is
    variable value_line : line;
    variable out_line : line;
    variable value_length : natural;
    variable shift_sign : boolean;
  begin
    write(value_line, value);
    value_length := value_line.all'length;
    if string_length = 0 then
      write(out_line, value_line.all);
    elsif string_length > value_length then
      if right_justify then
        if (value_line.all(value_line.all'left) <= '-') and not(fill_char = ' ') then
          shift_sign := true;
          write(out_line, value_line.all(value_line.all'left));
        end if;
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
      if shift_sign then
        write(out_line, value_line.all(value_line.all'left+1 to value_line.all'right));
      else
        write(out_line, value_line.all);
      end if;
      if not right_justify then
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
    elsif string_length < value_length then
      write(out_line, '#');
      write(out_line, value_line.all(value_length-string_length+2 to value_length));
    else
      write(out_line, value_line.all);
    end if;
    deallocate(value_line);
    return(out_line.all);
  end pad;

  ------------------------------------------------------------------------------
  -- remove separator characters at beginning and end of line
  ------------------------------------------------------------------------------
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line : line    := value;
    variable found      : boolean := false;
    variable position   : integer := 0;
  begin
    -- remove all separators in the beginning
    position := -1;
    for character_index in input_line'range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(position+1 to input_line'right) );
   end if;

   -- remove all separators in the end
    position := -1;
    for character_index in input_line'reverse_range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(input_line'left to position-1) );
   end if;

   value := input_line;
  end;

  procedure rm_side_separators(value : inout line) is
  begin
    rm_side_separators(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove multiple occurences of separator characters, keeping one single
  ------------------------------------------------------------------------------
  procedure trim_line(
    value : inout line;
    separators : in string
  ) is
    variable input_line: line := value;
    variable output_line: line := new string'("");
    variable is_separator, was_separator : boolean := false;
  begin
    rm_side_separators(input_line);
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not (is_separator and was_separator) then
        write(output_line, input_line.all(character_index));
      end if;
      was_separator := is_separator;
    end loop;

    value := output_line;
  end;

  procedure trim_line(value : inout line) is
  begin
    trim_line(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove all occurences of separator characters
  ------------------------------------------------------------------------------
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line   : line    := value;
    variable is_separator : boolean := false;
  begin

    -- remove separators from beginn and end of the line
    -- rm_separator_be(value, separators);

    -- empty output line
    value := new string'("");

    -- find all separator symbols
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not is_separator then
        write(value, input_line.all(character_index));
      end if;
    end loop;

  end;

  procedure rm_all_separators(value : inout line) is
  begin
    rm_all_separators(value, " _." & ht);
  end;

  ------------------------------------------------------------------------------
  -- read first "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  ) is
    variable input_line: line;
    variable position: natural := 0;
  begin
    input_line := value;
    for character_index in input_line.all'reverse_range loop
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position > 1 then
      first := new string'(input_line.all(input_line'left to position-1));
	    value := new string'(input_line(position+1 to input_line'right));
    else
      first := new string'(input_line.all);
	    value := new string'("");
    end if;
  end;

  procedure read_first(value : inout line; first : out line) is
  begin
    read_first(value, " :" & ht, first);
  end;

  ------------------------------------------------------------------------------
  -- read last "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  ) is
    variable input_line: line := value;
    variable position: natural := 0;
  begin
    for character_index in input_line'range loop
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position <= input_line'right and
       position >  0                then
      value := new string'(input_line(input_line'left to position-1));
      last  := new string'(input_line(position+1 to input_line'right));
    else
      last := new string'(input_line.all);
    end if;
  end;

  procedure read_last(value : inout line; last : out line) is
  begin
    read_last(value, " :" & ht, last);
  end;


  --============================================================================
  -- formatted string output, internal functions
  --

  ------------------------------------------------------------------------------
  -- get format specification
  ------------------------------------------------------------------------------
  procedure get_format_items(
    format          : string;
    right_justify   : out boolean;
    add_sign        : out boolean;
    fill_char       : out character;
    total_length    : out natural;
    point_precision : out natural;
    format_type     : inout line
  ) is
    variable find_sign : boolean := false;
    variable find_padding : boolean := false;
    variable find_length : boolean := false;
    variable find_precision : boolean := false;
    variable find_type : boolean := false;
    variable right_justify_int : boolean := true;
    variable total_length_int : natural := 0;
    variable point_precision_int : natural := 0;
  begin
    add_sign := false;
    fill_char := ' ';
    for index in 1 to format'length loop
      if find_type then
        write(format_type, format(index));
      end if;
      if find_precision then
        if (format(index) >= '0') and (format(index) <= '9') then
          point_precision_int := 10*point_precision_int + character'pos(format(index)) - character'pos('0');
          if format(index+1) >= 'A' then
            find_precision := false;
            find_type := true;
          end if;
        end if;
      end if;
      if find_length then
        if (format(index) >= '0') and (format(index) <= '9') then
          total_length_int := 10*total_length_int + character'pos(format(index)) - character'pos('0');
        end if;
        if format(index) = '.' then
          find_length := false;
          find_precision := true;
        elsif format(index+1) >= 'A' then
          find_length := false;
          find_type := true;
        end if;
      end if;
      if find_padding then
        if format(index) = '0' then
          if right_justify_int then
            fill_char := '0';
          end if;
        end if;
        find_padding := false;
        if format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if find_sign then
        if format(index) = '-' then
          right_justify_int := false;
        end if;
        if format(index) = '+' then
          add_sign := true;
        end if;
        find_sign := false;
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if format(index) = '%' then
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
    end loop;
    right_justify := right_justify_int;
    total_length := total_length_int;
    point_precision := point_precision_int;
  end get_format_items;


  ------------------------------------------------------------------------------
  -- formatted string output: converting std_ulogic to character
  ------------------------------------------------------------------------------
  function to_character(value: std_ulogic) return character is
    variable out_value: character;
  begin
    case value is
      when 'U' => out_value := 'U';
      when 'X' => out_value := 'X';
      when '0' => out_value := '0';
      when '1' => out_value := '1';
      when 'Z' => out_value := 'Z';
      when 'W' => out_value := 'W';
      when 'L' => out_value := 'L';
      when 'H' => out_value := 'H';
      when '-' => out_value := '-';
    end case;
    return(out_value);
  end to_character;

  ------------------------------------------------------------------------------
  -- formatted string output: binary integer
  ------------------------------------------------------------------------------
  function sprintf_b(value: std_ulogic_vector) return string is
    variable out_line : line;
  begin
    for index in value'range loop
      write(out_line, to_character(value(index)));
    end loop;
    return(out_line.all);
  end sprintf_b;

  ------------------------------------------------------------------------------
  -- formatted string output: decimal integer
  ------------------------------------------------------------------------------
  function sprintf_d(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    value           : integer
  ) return string is
    variable value_line : line;
  begin
    if add_sign and (value >= 0) then
      write(value_line, '+');
    end if;
    write(value_line, value);
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_d;

  ------------------------------------------------------------------------------
  -- formatted string output: fixed point real
  ------------------------------------------------------------------------------
  function sprintf_f(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    point_precision : natural;
    value           : real
  ) return string is
    variable point_precision_int : natural;
    variable integer_part : integer;
    variable decimal_part : natural;
    variable value_line : line;
  begin
    if point_precision = 0 then
      point_precision_int := 6;
    else
      point_precision_int := point_precision;
    end if;
    if value >= 0.0 then
      integer_part := integer(value-0.5);
    else
      integer_part := - integer(-value-0.5);
    end if;
    decimal_part := abs(integer((value-real(integer_part))*(10.0**point_precision_int)));
    if add_sign and (value >= 0.0) then
      write(value_line, '+');
    end if;
    write(value_line, integer_part);
    write(value_line, '.');
    write(value_line, sprintf_d(true, false, '0', point_precision_int, decimal_part));
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_f;

  ------------------------------------------------------------------------------
  -- formatted string output: hexadecimal integer
  ------------------------------------------------------------------------------
  function sprintf_X(
    extend_unsigned : boolean;
    value           : std_ulogic_vector
  ) return string is
    variable bit_count : positive;
    variable value_line : line;
    variable out_line : line;
    variable nibble: string(1 to 4);
  begin
    bit_count := value'length;
    while (bit_count mod 4) /= 0 loop
      if extend_unsigned then
        write(value_line, to_character('0'));
      else
        write(value_line, to_character(value(value'high)));
      end if;
      bit_count := bit_count + 1;
    end loop;
    write(value_line, sprintf_b(value));
    for index in value_line.all'range loop
      if (index mod 4) = 0 then
        nibble := value_line.all(index-3 to index);
        case nibble is
          when "0000" => write(out_line, 0);
          when "0001" => write(out_line, 1);
          when "0010" => write(out_line, 2);
          when "0011" => write(out_line, 3);
          when "0100" => write(out_line, 4);
          when "0101" => write(out_line, 5);
          when "0110" => write(out_line, 6);
          when "0111" => write(out_line, 7);
          when "1000" => write(out_line, 8);
          when "1001" => write(out_line, 9);
          when "1010" => write(out_line, 'A');
          when "1011" => write(out_line, 'B');
          when "1100" => write(out_line, 'C');
          when "1101" => write(out_line, 'D');
          when "1110" => write(out_line, 'E');
          when "1111" => write(out_line, 'F');
          when others => write(out_line, 'X');
        end case;
      end if;
    end loop;
    return(out_line.all);
  end sprintf_X;


  --============================================================================
  -- formatted string output, interface functions
  --

  ------------------------------------------------------------------------------
  -- integer
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : integer) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all = "b" then
      if string_length = 0 then
        string_length := 8;
      end if;
      return(sprintf_b(std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, string_length, value));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, real(value)));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if string_length = 0 then
        string_length := 8;
      end if;
      string_length := 4*string_length;
      if format_type.all = "X" then
        return(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
      else
        return(lc(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0)))));
      end if;
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- real
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : real) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "d") or (point_precision = 0) then
      return(sprintf_d(right_justify, add_sign, fill_char,
                       string_length, integer(value)));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, value));
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable logic_vector: std_logic_vector(1 to 1);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      logic_vector(1) := value;
      return(sprintf(format, std_ulogic_vector(logic_vector)));
    else
      return("Not a std_logic format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_ulogic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_ulogic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if format_type.all = "b" then
      return(pad(sprintf_b(value), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(unsigned(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if format_type.all = "X" then
        return(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a std_ulogic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not a std_logic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- unsigned
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : unsigned) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not an unsigned format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- signed
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : signed) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if (fill_char = '0') and (value(value'left) = '1') then
      fill_char := '1';
    end if;
    if format_type.all = "b" then
      return(pad(sprintf_b(std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(signed(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if fill_char = '1' then
        fill_char := 'F';
      end if;
      if format_type.all = "X" then
        return(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a signed format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- time
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : time) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable scaling : real;
    variable base_time : time;
    variable unit : string(1 to 3);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all(format_type.all'left) = 't' then
      scaling := 10.0**point_precision;
      if format_type.all = "tp" then
        base_time := 1 ps;
        unit := " ps";
      elsif format_type.all = "tn" then
        base_time := 1 ns;
        unit := " ns";
      elsif format_type.all = "tu" then
        base_time := 1 us;
        unit := " us";
      elsif format_type.all = "tm" then
        base_time := 1 ms;
        unit := " ms";
      elsif format_type.all = "ts" then
        base_time := 1 sec;
        unit := " s.";
      else
        return("Undefined time format: '" & format_type.all & "'");
      end if;
      if point_precision = 0 then
        return(sprintf_d(right_justify, add_sign, fill_char,
                         string_length, value/base_time) & unit);
      else
        return(sprintf_f(right_justify, add_sign, fill_char, string_length,
                         point_precision, real(scaling*value/base_time)/scaling) & unit);
      end if;
    else
      return("Not a time format: '" & format_type.all & "'");
    end if;
  end sprintf;


  --============================================================================
  -- formatted string input
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- read a nibble out of a character
  ------------------------------------------------------------------------------
  function sscanf(value : character) return natural is
  begin
    if (value >= '0') and (value <= '9') then
      return(character'pos(value) - character'pos('0'));
    elsif (value >= 'a') and (value <= 'f') then
      return(character'pos(value) - character'pos('a') + 10);
    elsif (value >= 'A') and (value <= 'F') then
      return(character'pos(value) - character'pos('A') + 10);
    else
      return(0);
    end if;
  end sscanf;

  function sscanf(value : character) return nibbleUnsignedType is
  begin
    return(to_unsigned(sscanf(value), nibbleUnsignedType'length));
  end sscanf;

  function sscanf(value : character) return nibbleUlogicType is
    variable unsigned_value : nibbleUnsignedType;
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end sscanf;

  ------------------------------------------------------------------------------
  -- read an binary word out of a string
  ------------------------------------------------------------------------------
  function sscanf(value : string) return natural is
    variable integer_value : natural;
  begin
    integer_value := 0;
    for index in value'left to value'right loop
      integer_value := integer_value*16 + sscanf(value(index));
    end loop;
    return(integer_value);
  end;

  function sscanf(value : string) return unsigned is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := to_unsigned(0,unsigned_value'length);
    for index in value'left to value'right loop
      unsigned_value := shift_left(unsigned_value,4) + to_unsigned(sscanf(value(index)),4);
    end loop;
    return(unsigned_value);
  end;

  function sscanf(value : string) return std_ulogic_vector is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end;

  ------------------------------------------------------------------------------
  -- read time from a string
  -- time can be formated as follows:
  --   "1ps" or "1 ps" or " 1 ps " or " 1ps"
  -- possible time units are: hr, min, sec, ms, us, ns, ps, fs
  ------------------------------------------------------------------------------
  procedure sscanf(
     value    : inout line;
     time_val : out time
  ) is
      variable time_line  : line := value;
      variable time_base  : string(1 to 3);
      variable time_value : integer;
      variable time_int   : time;
  begin
    -- remove all spaces and tabs
    rm_all_separators(time_line);

    -- strip time base (3 last characters)
    time_base := time_line(time_line'right-2 to time_line'right);

    -- separate time value and base
    if time_base(2 to 3) = "hr" then
        time_int   := 1 hr;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base = "min" then
        time_int   := 1 min;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base = "sec" then
        time_int   := 1 sec;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base(2 to 3) = "ms" then
        time_int   := 1 ms;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "us" then
        time_int   := 1 us;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ns" then
        time_int   := 1 ns;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ps" then
        time_int   := 1 ps;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "fs" then
        time_int   := 1 fs;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    else
        time_int   := 0 ps;
        time_value := 1;
    end if;

    -- build time from value and base
    time_val := time_int * time_value;

  end;

  function sscanf(value : string) return time is
    variable value_line : line;
    variable time_val   : time;
  begin
    value_line := new string'(value);
    sscanf(value_line, time_val);
    return(time_val);
  end;

END testUtils;




LIBRARY std;
  USE std.textio.ALL;

LIBRARY ieee;
  USE ieee.std_logic_textio.ALL;

LIBRARY Common_test;
  USE Common_test.testutils.all;

Library Kart;
  Use Kart.Kart.all;

ARCHITECTURE test OF dcMotorController_tester IS

  constant clockPeriod  : time := 1.0/CLOCK_FREQUENCY * 1 sec;
  signal sClock         : std_uLogic := '1';
  signal sReset         : std_uLogic ;

  constant testInterval : time := 1 ms;
  signal testInfo       : string(1 to 40) := (others => ' ');

  signal hardwareOrientation : natural;

  -- Control values
  constant restart: natural := 16#10#;
  constant btConnected: natural := 16#20#;
  signal absSpeed: integer;
  constant pwmDivideValue: positive := 10;
  constant pwmPeriod : time :=
    (2.0**(DC_pwmStepsBitNb-1) * real(pwmDivideValue) * sec) / CLOCK_FREQUENCY;
  constant speedMaxValue: positive := 2**(DC_pwmStepsBitNb-1) - 1;
                                                               
  -- PWM mean value
  constant pwmLowpassShift: positive := 8;
  signal pwmLowpassAccumulator, motorSpeed: real := 0.0;
  signal motorSpeed_int: integer := 0;

  -- Registers definitions
  constant baseReadAddr : natural := REG_DCMOT_ADDR * 2**6;
  constant baseWriteAddr : natural := baseReadAddr + 1 * 2**5;

  constant prescalerWRAddr : natural :=
    baseWriteAddr + DC_PRESCALER_REG_POS;
  constant speedWRAddr : natural :=
    baseWriteAddr + DC_SPEED_REG_POS;

BEGIN
  ------------------------------------------------------------------------------
                                                              -- reset and clock
  sReset <= '1', '0' after 4*clockPeriod;
  reset <= sReset;

  sClock <= not sClock after clockPeriod/2;
  clock <= transport sClock after 0.9*clockPeriod;

  ------------------------------------------------------------------------------
                                                                       -- others
  hwOrientation <= dataRegisterType
  (
    to_unsigned(hardwareOrientation, hwOrientation'length)
  );

  ------------------------------------------------------------------------------
                                                                -- test sequence
  process

    procedure setReg(constant address : in natural;
                     data    : in integer) is
    begin
      assert(
        to_unsigned(address, addressIn'length)(REG_ADDR_GET_BIT_POSITION)
        = '1') report "Address is not writable" severity failure;
      addressIn <= symbolSizeType(to_unsigned(address, addressIn'length));
      dataIn <= dataRegisterType(to_signed(data, dataIn'length));
      regWr <= '1', '0' after clockPeriod * 1.1;
    end procedure;

  begin
    -- Init signals
    hardwareOrientation <= 0;
    dataIn <= (others=>'0');
    addressIn <= (others=>'0');
    regWr <= '0';
    dcMotorSendAuth <= '1';
    absSpeed <= 65535;

    write(output,
      lf & lf & lf &
      "----------------------------------------------------------------" & lf &
      "-- Starting testbench" & lf &
      "--" &
      lf & lf
    );
                                                             -- send hardwareOrientation
    testInfo <= pad("Init", testInfo'length);
    write(output,
      "Setting hardware hardwareOrientation" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    hardwareOrientation <= btConnected + 2#111#;
    wait for testInterval;

                                                               -- send prescaler
    testInfo <= pad("Sending prescaler", testInfo'length);
    write(output,
      "Sending prescaler value" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    setReg(prescalerWRAddr, pwmDivideValue);
    wait for testInterval;

                                                               -- send 1/3 speed
    testInfo <= pad("speed 1/3", testInfo'length);
    write(output,
      "Sending speed control to 1/3 max value forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue / 3;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '1'
      report "Direction error"
      severity error;
    assert forwards /= '1'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int-absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int-absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                               -- send 2/3 speed
    testInfo <= pad("speed 2/3", testInfo'length);
    write(output,
      "Sending speed control to 2/3 max value forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue * 2/3;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '1'
      report "Direction error"
      severity error;
    assert forwards /= '1'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int-absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int-absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                              -- send full speed
    testInfo <= pad("full speed", testInfo'length);
    write(output,
      "Sending speed control to max value forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '1'
      report "Direction error"
      severity error;
    assert forwards /= '1'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int-absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int-absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                     -- send 1/3 speed backwards
    testInfo <= pad("speed 1/3 back", testInfo'length);
    write(output,
      "Sending speed control to 1/3 max value backwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue / 3;
    wait for clockPeriod;
    setReg(speedWRAddr, -absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '0'
      report "Direction error"
      severity error;
    assert forwards /= '0'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int+absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int+absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                     -- send 2/3 speed backwards
    testInfo <= pad("speed 2/3 back", testInfo'length);
    write(output,
      "Sending speed control to 2/3 max value backwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue * 2/3;
    wait for clockPeriod;
    setReg(speedWRAddr, -absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '0'
      report "Direction error"
      severity error;
    assert forwards /= '0'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int+absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int+absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                    -- send full speed backwards
    testInfo <= pad("full speed back", testInfo'length);
    write(output,
      "Sending speed control to max value backwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue;
    wait for clockPeriod;
    setReg(speedWRAddr, -absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '0'
      report "Direction error"
      severity error;
    assert forwards /= '0'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int+absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int+absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                   -- change hardwareOrientation
    testInfo <= pad("hardwareOrientation", testInfo'length);
    write(output,
      "Changing hardware hardwareOrientation" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    hardwareOrientation <= btConnected + 2#110#;
    wait for testInterval;

                                                              -- send half speed
    testInfo <= pad("half speed", testInfo'length);
    write(output,
      "Sending speed control to half max value forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= (speedMaxValue+1) / 2;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '0'
      report "Direction error"
      severity error;
    assert forwards /= '0'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int-absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int-absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                              -- send full speed
    testInfo <= pad("full speed", testInfo'length);
    write(output,
      "Sending speed control to max value forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '0'
      report "Direction error"
      severity error;
    assert forwards /= '0'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int-absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int-absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                    -- send half speed backwards
    testInfo <= pad("half speed back", testInfo'length);
    write(output,
      "Sending speed control to half max value backwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= (speedMaxValue+1) / 2;
    wait for clockPeriod;
    setReg(speedWRAddr, -absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '1'
      report "Direction error"
      severity error;
    assert forwards /= '1'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int+absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int+absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                    -- send full speed backwards
    testInfo <= pad("full speed back", testInfo'length);
    write(output,
      "Sending speed control to max value backwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= speedMaxValue;
    wait for clockPeriod;
    setReg(speedWRAddr, -absSpeed);
    wait for 10*pwmPeriod;
    assert forwards = '1'
      report "Direction error"
      severity error;
    assert forwards /= '1'
      report "Direction OK"
      severity note;
    assert abs(motorSpeed_int+absSpeed) <= 2
      report "PWM error"
      severity error;
    assert abs(motorSpeed_int+absSpeed) > 2
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                                 -- send speed 2
    testInfo <= pad("speed 2", testInfo'length);
    write(output,
      "Sending speed control to 2 forwards" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    absSpeed <= 2;
    wait for clockPeriod;
    setReg(speedWRAddr, absSpeed);
    wait for 10*pwmPeriod;
    assert motorSpeed_int > 0
      report "PWM error"
      severity error;
    assert motorSpeed_int <= 0
      report "PWM Ok"
      severity note;
    wait for testInterval;

                                                                 -- send restart
    testInfo <= pad("restart", testInfo'length);
    write(output,
      "Sending restart control" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    hardwareOrientation <= restart + btConnected + 2#111#;
    wait for 10*pwmPeriod;
    assert motorSpeed_int = 0
      report "PWM error"
      severity error;
    assert motorSpeed_int /= 0
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                                 -- stop restart
    write(output,
      "Stopping restart control" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    hardwareOrientation <= btConnected + 2#111#;
    wait for 10*pwmPeriod;
    assert motorSpeed_int > 0
      report "PWM error"
      severity error;
    assert motorSpeed_int <= 0
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                          -- loose BT connection
    testInfo <= pad("loose BT connection", testInfo'length);
    write(output,
      "Loosing BT connection" &
      " at time " & integer'image(now/1 us) & " us" &
      lf & lf
    );
    hardwareOrientation <= 2#111#;
    wait for 10*pwmPeriod;
    assert motorSpeed_int = 0
      report "PWM error"
      severity error;
    assert motorSpeed_int /= 0
      report "PWM OK"
      severity note;
    wait for testInterval;

                                                            -- end of simulation
    assert false
      report "End of simulation"
      severity failure;
    wait;
  end process;

  --============================================================================
                                                                  -- PWM lowpass
  lowpassIntegrator: process
  begin
    wait until rising_edge(clock);
    if pwm = '1' then
      if (forwards xor to_unsigned(hardwareOrientation, hwOrientation'length)(0))
           = '0' then
        pwmLowpassAccumulator <= pwmLowpassAccumulator - motorSpeed + 1.0;
      else
        pwmLowpassAccumulator <= pwmLowpassAccumulator - motorSpeed - 1.0;
      end if;
    else
      pwmLowpassAccumulator <= pwmLowpassAccumulator - motorSpeed;
    end if;
  end process lowpassIntegrator;

  motorSpeed <= pwmLowpassAccumulator / 2.0**pwmLowpassShift;
  motorSpeed_int <= integer(real(speedMaxValue) * motorSpeed);

END ARCHITECTURE test;




--
-- VHDL Architecture DcMotor_test.dcMotorController_tb.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:24:01 09.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY Kart;
USE Kart.Kart.ALL;

LIBRARY DcMotor;
LIBRARY DcMotor_test;

ARCHITECTURE struct OF dcMotorController_tb IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL addressIn            : symbolSizeType;
    SIGNAL clock                : std_ulogic;
    SIGNAL dataIn               : dataRegisterType;
    SIGNAL dcMotorAddressToSend : symbolSizeType;
    SIGNAL dcMotorDataToSend    : dataRegisterType;
    SIGNAL dcMotorSendAuth      : std_ulogic;
    SIGNAL dcMotorSendRequest   : std_ulogic;
    SIGNAL forwards             : std_ulogic;
    SIGNAL hwOrientation        : dataRegisterType;
    SIGNAL pwm                  : std_ulogic;
    SIGNAL regWr                : std_ulogic;
    SIGNAL reset                : std_ulogic;


    -- Component Declarations
    COMPONENT dcMotorController
    PORT (
        addressIn            : IN     symbolSizeType ;
        clock                : IN     std_ulogic ;
        dataIn               : IN     dataRegisterType ;
        dcMotorSendAuth      : IN     std_ulogic ;
        hwOrientation        : IN     dataRegisterType ;
        regWr                : IN     std_ulogic ;
        reset                : IN     std_ulogic ;
        dcMotorAddressToSend : OUT    symbolSizeType ;
        dcMotorDataToSend    : OUT    dataRegisterType ;
        dcMotorSendRequest   : OUT    std_ulogic ;
        forwards             : OUT    std_ulogic ;
        pwm                  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT dcMotorController_tester
    PORT (
        dcMotorAddressToSend : IN     symbolSizeType ;
        dcMotorDataToSend    : IN     dataRegisterType ;
        dcMotorSendRequest   : IN     std_ulogic ;
        forwards             : IN     std_ulogic ;
        pwm                  : IN     std_ulogic ;
        addressIn            : OUT    symbolSizeType ;
        clock                : OUT    std_ulogic ;
        dataIn               : OUT    dataRegisterType ;
        dcMotorSendAuth      : OUT    std_ulogic ;
        hwOrientation        : OUT    dataRegisterType ;
        regWr                : OUT    std_ulogic ;
        reset                : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : dcMotorController USE ENTITY DcMotor.dcMotorController;
    FOR ALL : dcMotorController_tester USE ENTITY DcMotor_test.dcMotorController_tester;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_DC : dcMotorController
        PORT MAP (
            addressIn            => addressIn,
            clock                => clock,
            dataIn               => dataIn,
            dcMotorSendAuth      => dcMotorSendAuth,
            hwOrientation        => hwOrientation,
            regWr                => regWr,
            reset                => reset,
            dcMotorAddressToSend => dcMotorAddressToSend,
            dcMotorDataToSend    => dcMotorDataToSend,
            dcMotorSendRequest   => dcMotorSendRequest,
            forwards             => forwards,
            pwm                  => pwm
        );
    I_tester : dcMotorController_tester
        PORT MAP (
            dcMotorAddressToSend => dcMotorAddressToSend,
            dcMotorDataToSend    => dcMotorDataToSend,
            dcMotorSendRequest   => dcMotorSendRequest,
            forwards             => forwards,
            pwm                  => pwm,
            addressIn            => addressIn,
            clock                => clock,
            dataIn               => dataIn,
            dcMotorSendAuth      => dcMotorSendAuth,
            hwOrientation        => hwOrientation,
            regWr                => regWr,
            reset                => reset
        );

END struct;




